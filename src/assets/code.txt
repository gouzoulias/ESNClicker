// src/Game/Game.tsx
import * as _ from 'lodash';
import React, { useCallback, useEffect, useState } from 'react';
import { useTick } from '../Utils/useTick.ts';
import { createSaveGame, loadGameFromLocalStorage, SaveGame, saveGameToLocalStorage } from '../Utils/SaveGame.ts';
import { Aux } from './Auxiliary.ts';
import { Dev } from './Dev.ts';
import { gameContext, gameStateDefaultValues as defaultValues, GameState, PriceIncrease } from './GameContext.ts';
import { ProductionItemInfo } from './ItemInfo.ts';
import { PO } from './POs.ts';
import { Upgrade, UpgradeInfos } from './Upgrade.ts';

export const Game = ({ children }: React.PropsWithChildren) => {
  const [codeLines, setCodeLines] = useState(defaultValues.codeLines);
  const [totalCodeLinesAccumulated, setTotalCodeLinesAccumulated] = useState(defaultValues.totalCodeLinesAccumulated);

  const [money, setMoney] = useState(defaultValues.money);
  const [totalMoneyAccumulated, setTotalMoneyAccumulated] = useState(defaultValues.totalMoneyAccumulated);

  const [boughtUpgrade, setBoughtUpgrade] = useState(defaultValues.boughtUpgrade);
  const [activatedUpgrades, setActivatedUpgrades] = useState(defaultValues.activatedUpgrades);

  const [manualProductivity, setManualProductivity] = useState(defaultValues.manualProductivity);
  const [codePrice, setCodePrice] = useState(defaultValues.codePrice);
  const [manualSellingForce, setManualSellingForce] = useState(defaultValues.manualSellingForce);

  const [devTeamInfo, setDevTeamInfo] = useState(defaultValues.devTeamInfo);

  const [poTeamInfo, setPoTeamInfo] = useState(defaultValues.poTeamInfo);

  const [unlockedAux, setUnlockedAux] = useState(defaultValues.unlockedAux);
  const [auxTeam, setAuxTeam] = useState(defaultValues.auxTeam);

  // Chargement de la sauvegarde au démarrage
  useEffect(() => {
    const savedGame = loadGameFromLocalStorage();
    if (savedGame) {
      setCodeLines(savedGame.codeLines);
      setTotalCodeLinesAccumulated(savedGame.totalCodeLinesAccumulated);
      setMoney(savedGame.money);
      setTotalMoneyAccumulated(savedGame.totalMoneyAccumulated);
      setBoughtUpgrade(savedGame.boughtUpgrade);
      setActivatedUpgrades(savedGame.activatedUpgrades);
      setCodePrice(savedGame.codePrice);
      setManualProductivity(savedGame.manualProductivity);
      setManualSellingForce(savedGame.manualSellingForce);
      setDevTeamInfo(savedGame.devTeamInfo);
      setPoTeamInfo(savedGame.poTeamInfo);
      setUnlockedAux(savedGame.unlockedAux);
      setAuxTeam(savedGame.auxTeam);
    }
  }, []);

  // État du jeu actuel (sans les méthodes)
  const currentGameState: GameState = {
    codeLines,
    totalCodeLinesAccumulated,
    money,
    totalMoneyAccumulated,
    boughtUpgrade,
    activatedUpgrades,
    codePrice,
    manualProductivity,
    manualSellingForce,
    devTeamInfo,
    poTeamInfo,
    unlockedAux,
    auxTeam,
  };

  useEffect(() => {
    const interval = setInterval(() => {
      const saveGame = createSaveGame(currentGameState);
      saveGameToLocalStorage(saveGame);
    }, 10000); // Sauvegarde toutes les 10 secondes

    return () => clearInterval(interval);
  }, [currentGameState]);

  const updateDevTeam = useCallback((editDev: (dev: Dev, devInfo: ProductionItemInfo) => ProductionItemInfo) => {
    setDevTeamInfo((prevState) =>
      _.reduce(
        prevState,
        (acc, devInfo, dev) => ({
          ...acc,
          [dev]: editDev(dev as Dev, devInfo),
        }),
        {} as Record<Dev, ProductionItemInfo>,
      ),
    );
  }, []);

  const updatePOTeam = useCallback((editDev: (po: PO, poInfo: ProductionItemInfo) => ProductionItemInfo) => {
    setPoTeamInfo((prevState) =>
      _.reduce(
        prevState,
        (acc, poInfo, po) => ({
          ...acc,
          [po]: editDev(po as PO, poInfo),
        }),
        {} as Record<PO, ProductionItemInfo>,
      ),
    );
  }, []);

  const addCodeLines = useCallback((nb: number) => {
    setCodeLines((prevState) => prevState + nb);
    if (nb > 0) {
      setTotalCodeLinesAccumulated((prevState) => prevState + nb);
    }
  }, []);

  const addMoney = useCallback((nb: number) => {
    setMoney((prevState) => prevState + nb);
    if (nb > 0) {
      setTotalMoneyAccumulated((prevState) => prevState + nb);
    }
  }, []);

  const createManualLine = useCallback(
    (nbLines: number) => {
      addCodeLines(nbLines);
    },
    [addCodeLines],
  );

  const buyDev = useCallback(
    (dev: Dev) => {
      const devPrice: number = devTeamInfo[dev].price;
      if (money >= devPrice) {
        console.log('addMoney : ', -devPrice);
        addMoney(-devPrice);
        updateDevTeam((prevDev, devInfo) =>
          prevDev === dev
            ? ({
                ...devInfo,
                numberOwned: devInfo.numberOwned + 1,
                price: devInfo.price * PriceIncrease,
              } as ProductionItemInfo)
            : devInfo,
        );
      }
    },
    [addMoney, devTeamInfo, money, updateDevTeam],
  );

  const buyPO = useCallback(
    (po: PO) => {
      const poPrice: number = poTeamInfo[po].price;
      if (money >= poPrice) {
        addMoney(-poPrice);
        updatePOTeam((prevPO, poInfo) =>
          prevPO === po
            ? ({
                ...poInfo,
                numberOwned: poInfo.numberOwned + 1,
                price: poInfo.price * PriceIncrease,
              } as ProductionItemInfo)
            : poInfo,
        );
      }
    },
    [addMoney, money, poTeamInfo, updatePOTeam],
  );

  const buyAux = useCallback((aux: Aux) => {
    setAuxTeam((prevState) => ({
      ...prevState,
      [aux]: prevState[aux] + 1,
    }));
  }, []);

  const buyUpgrade = useCallback(
    (upgrade: Upgrade) => {
      if (money >= UpgradeInfos[upgrade].price) {
        setMoney((prevState) => prevState - UpgradeInfos[upgrade].price);
        setBoughtUpgrade((prevState) => ({
          ...prevState,
          [upgrade]: true,
        }));
        switch (upgrade) {
          case Upgrade.MecanicalKeyboard:
            setManualProductivity((prevState) => prevState * 1.25);
            break;
          case Upgrade.GamingChair:
            setManualProductivity((prevState) => prevState * 1.5);
            break;
          case Upgrade.SecondMonitor:
            setManualProductivity((prevState) => prevState * 2);
            break;
          case Upgrade.Smartphone:
            setManualSellingForce((prevState) => prevState * 2);
            break;
          case Upgrade['5G']:
            setManualSellingForce((prevState) => prevState * 5);
            break;
          case Upgrade.Linter:
            setCodePrice((prevState) => prevState * 1.25);
            break;
          case Upgrade.CofeeMachine:
            updateDevTeam((_dev, devInfo) => ({
              ...devInfo,
              productivity: devInfo.productivity * 2,
            }));
            break;
          case Upgrade.OpenSpace:
            updateDevTeam((_dev, devInfo) => ({
              ...devInfo,
              productivity: devInfo.productivity * 2,
            }));
            updatePOTeam((_po, poInfo) => ({
              ...poInfo,
              productivity: poInfo.productivity * 2,
            }));
            break;
        }
      }
    },
    [money, updateDevTeam, updatePOTeam],
  );

  const sellCode = useCallback(
    (nbLines: number) => {
      if (nbLines !== 0) {
        const codeLinesToSell = Math.min(codeLines, nbLines);
        addMoney(codeLinesToSell * codePrice);
        addCodeLines(-codeLinesToSell);
      }
    },
    [addCodeLines, addMoney, codeLines, codePrice],
  );

  const loadSaveGame = useCallback((saveGame: SaveGame) => {
    setCodeLines(saveGame.codeLines);
    setTotalCodeLinesAccumulated(saveGame.totalCodeLinesAccumulated);
    setMoney(saveGame.money);
    setTotalMoneyAccumulated(saveGame.totalMoneyAccumulated);
    setBoughtUpgrade(saveGame.boughtUpgrade);
    setActivatedUpgrades(saveGame.activatedUpgrades);
    setCodePrice(saveGame.codePrice);
    setManualProductivity(saveGame.manualProductivity);
    setManualSellingForce(saveGame.manualSellingForce);
    setDevTeamInfo(saveGame.devTeamInfo);
    setPoTeamInfo(saveGame.poTeamInfo);
    setUnlockedAux(saveGame.unlockedAux);
    setAuxTeam(saveGame.auxTeam);
  }, []);

  const resetGame = useCallback(() => {
    setCodeLines(defaultValues.codeLines);
    setTotalCodeLinesAccumulated(defaultValues.totalCodeLinesAccumulated);
    setMoney(defaultValues.money);
    setTotalMoneyAccumulated(defaultValues.totalMoneyAccumulated);
    setBoughtUpgrade(defaultValues.boughtUpgrade);
    setActivatedUpgrades(defaultValues.activatedUpgrades);
    setCodePrice(defaultValues.codePrice);
    setManualProductivity(defaultValues.manualProductivity);
    setManualSellingForce(defaultValues.manualSellingForce);
    setDevTeamInfo(defaultValues.devTeamInfo);
    setPoTeamInfo(defaultValues.poTeamInfo);
    setUnlockedAux(defaultValues.unlockedAux);
    setAuxTeam(defaultValues.auxTeam);
  }, []);

  const gameTick = useCallback(
    (deltaTimeInSecond: number) => {
      const codeProduction: number = _.chain(devTeamInfo)
        .map(({ numberOwned, productivity }) => numberOwned * productivity * deltaTimeInSecond)
        .reduce((prev, curr) => prev + curr, 0)
        .value();

      const sellingForce: number = _.chain(poTeamInfo)
        .map(({ numberOwned, productivity }) => numberOwned * productivity * deltaTimeInSecond)
        .sum()
        .value();

      if (codeLines + codeProduction < sellingForce) {
        addMoney((codeLines + codeProduction) * codePrice);
        addCodeLines(-codeLines);
      } else {
        sellCode(sellingForce);
        addCodeLines(codeProduction);
      }
    },
    [addCodeLines, addMoney, codeLines, codePrice, devTeamInfo, poTeamInfo, sellCode],
  );

  useTick(gameTick, 100);

  return (
    <gameContext.Provider
      value={{
        codeLines,
        totalCodeLinesAccumulated,

        money,
        totalMoneyAccumulated,

        boughtUpgrade,
        activatedUpgrades,

        devTeamInfo,

        poTeamInfo,

        manualProductivity,
        codePrice,
        manualSellingForce,

        unlockedAux,
        auxTeam,

        createManualLine,

        buyDev,
        buyPO,
        buyAux,
        buyUpgrade,

        sellCode,
        loadSaveGame,
        resetGame,
      }}
    >
      {children}
    </gameContext.Provider>
  );
};
