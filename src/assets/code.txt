// src/Utils/useTick.ts
import { useEffect, useRef } from 'react';

// Code snippet from
// https://stackoverflow.com/questions/53024496/state-not-updating-when-using-react-state-hook-within-setinterval
export const useTick = (callback: (deltaTimeInSecond: number) => void, deltaTimeMS: number) => {
  const intervalRef = useRef<number>();
  const callbackRef = useRef(callback);

  // Remember the latest callback:
  //
  // Without this, if you change the callback, when setInterval ticks again, it
  // will still call your old callback.
  //
  // If you add `callback` to useEffect's deps, it will work fine but the
  // interval will be reset.

  useEffect(() => {
    callbackRef.current = callback;
  }, [callback]);

  // Set up the interval:

  useEffect(() => {
    intervalRef.current = window.setInterval(() => callbackRef.current(deltaTimeMS / 1000), deltaTimeMS);

    // Clear interval if the components is unmounted or the delay changes:
    return () => window.clearInterval(intervalRef.current);
  }, [deltaTimeMS]);

  // Returns a ref to the interval ID in case you want to clear it manually:
  return intervalRef;
};
 
// src/Utils/util.ts
import * as _ from 'lodash';

type Enum = Record<string, number | string>;

export const initFromEnum = <A extends Enum, B extends object | number | boolean | string>(
  enumType: A,
  defaultValue: B | ((val: A[keyof A]) => B),
): Record<A[keyof A], B> => {
  const enumObject = {} as Record<A[keyof A], B>;

  _.forEach(enumType, (value: A[keyof A]) => {
    if (typeof defaultValue === 'function') {
      enumObject[value] = defaultValue(value);
    } else {
      enumObject[value] = defaultValue;
    }
  });

  return enumObject;
};
 
// src/Game/Game.tsx
import * as _ from 'lodash';
import React, { useCallback, useState } from 'react';
import { useTick } from '../Utils/useTick.ts';
import { Aux } from './Aux.ts';
import { Dev } from './Dev.ts';
import { gameContext, gameContextDefaultValues, PriceIncrease } from './GameContext.ts';
import { ProductionItemInfo } from './ItemInfo.ts';
import { PO } from './POs.ts';
import { Upgrade, UpgradeInfos } from './Upgrade.ts';

export const Game = ({ children }: React.PropsWithChildren) => {
  const [codeLines, setCodeLines] = useState(gameContextDefaultValues.codeLines);
  const [totalCodeLinesAccumulated, setTotalCodeLinesAccumulated] = useState(gameContextDefaultValues.totalCodeLinesAccumulated);

  const [money, setMoney] = useState(gameContextDefaultValues.money);
  const [totalMoneyAccumulated, setTotalMoneyAccumulated] = useState(gameContextDefaultValues.totalMoneyAccumulated);

  const [boughtUpgrade, setBoughtUpgrade] = useState(gameContextDefaultValues.boughtUpgrade);
  const [activatedUpgrades] = useState(gameContextDefaultValues.activatedUpgrades);

  const [manualProductivity, setManualProductivity] = useState(gameContextDefaultValues.manualProductivity);
  const [codePrice] = useState(gameContextDefaultValues.codePrice);
  const [manualSellingForce] = useState(gameContextDefaultValues.manualSellingForce);

  const [devTeamInfo, setDevTeamInfo] = useState(gameContextDefaultValues.devTeamInfo);

  const [poTeamInfo, setPoTeamInfo] = useState(gameContextDefaultValues.poTeamInfo);

  const [unlockedAux] = useState(gameContextDefaultValues.unlockedAux);
  const [auxTeam, setAuxTeam] = useState(gameContextDefaultValues.auxTeam);

  const addCodeLines = useCallback((nb: number) => {
    setCodeLines((prevState) => prevState + nb);
    setTotalCodeLinesAccumulated((prevState) => prevState + nb);
  }, []);

  const addMoney = useCallback((nb: number) => {
    setMoney((prevState) => prevState + nb);
    setTotalMoneyAccumulated((prevState) => prevState + nb);
  }, []);

  const createManualLine = useCallback(
    (nbLines: number) => {
      addCodeLines(nbLines);
    },
    [addCodeLines],
  );

  const buyDev = useCallback(
    (dev: Dev) => {
      const devPrice: number = devTeamInfo[dev].price;
      if (money >= devPrice) {
        setMoney((prevState) => prevState - devPrice);
        setDevTeamInfo((prevState) => {
          return {
            ...prevState,
            [dev]: {
              ...prevState[dev],
              numberOwned: prevState[dev].numberOwned + 1,
              price: prevState[dev].price * PriceIncrease,
            } as ProductionItemInfo,
          } as Record<Dev, ProductionItemInfo>;
        });
      }
    },
    [devTeamInfo, money],
  );

  const buyPO = useCallback(
    (po: PO) => {
      const poPrice: number = poTeamInfo[po].price;
      if (money >= poPrice) {
        setMoney((prevState) => prevState - poPrice);
        setPoTeamInfo((prevState) => {
          return {
            ...prevState,
            [po]: {
              ...prevState[po],
              numberOwned: prevState[po].numberOwned + 1,
              price: prevState[po].price * PriceIncrease,
            } as ProductionItemInfo,
          } as Record<PO, ProductionItemInfo>;
        });
      }
    },
    [money, poTeamInfo],
  );

  const buyAux = useCallback((aux: Aux) => {
    setAuxTeam((prevState) => ({
      ...prevState,
      [aux]: prevState[aux] + 1,
    }));
  }, []);

  const buyUpgrade = useCallback(
    (upgrade: Upgrade) => {
      if (money >= UpgradeInfos[upgrade].price) {
        setMoney((prevState) => prevState - UpgradeInfos[upgrade].price);
        setBoughtUpgrade((prevState) => ({
          ...prevState,
          [upgrade]: true,
        }));
        switch (upgrade) {
          case Upgrade.MecanicalKeyboard:
          case Upgrade.GamingChair:
            setManualProductivity((prevState) => prevState * 2);
            break;
        }
      }
    },
    [money],
  );

  const sellCode = useCallback(
    (nbLines: number) => {
      setCodeLines((currentCodeLines) => {
        const codeLinesToSell = Math.min(currentCodeLines, nbLines);
        addMoney(codeLinesToSell * codePrice);
        return currentCodeLines - codeLinesToSell;
      });
    },
    [addMoney, codePrice],
  );

  const gameTick = useCallback(
    (deltaTimeInSecond: number) => {
      addCodeLines(
        _.chain(devTeamInfo)
          .map(({ numberOwned, productivity }) => numberOwned * productivity * deltaTimeInSecond)
          .reduce((prev, curr) => prev + curr, 0)
          .value(),
      );
      sellCode(
        _.chain(poTeamInfo)
          .map(({ numberOwned, productivity }) => numberOwned * productivity * deltaTimeInSecond)
          .sum()
          .value(),
      );
    },
    [addCodeLines, devTeamInfo, poTeamInfo, sellCode],
  );

  useTick(gameTick, 100);

  return (
    <gameContext.Provider
      value={{
        codeLines,
        totalCodeLinesAccumulated,

        money,
        totalMoneyAccumulated,

        boughtUpgrade,
        activatedUpgrades,

        devTeamInfo,

        poTeamInfo,

        manualProductivity,
        codePrice,
        manualSellingForce,

        unlockedAux,
        auxTeam,

        createManualLine,

        buyDev,
        buyPO,
        buyAux,
        buyUpgrade,

        sellCode,
      }}
    >
      {children}
    </gameContext.Provider>
  );
};
